

在本文里，我将说明为什么 Erlang 的运行时会与其它语言的运行时有所不同，还将说明为什么它经常会采取放弃吞吐量的方式以换取更小的延时。

摘要：Erlang 与其它大多数语言的运行时差异源于双方有着不同的目标价值。我们常常发现 Erlang 在进程不多时表现不佳，反而在进程很多时表现优异，原因也在于此。

长久以来，关于 Erlang 的调度方式问题总是被人们问起。尽管本文是真实情况的缩减版本，但仍可作为针对这个问题的解答。需要留意的是，本文是基于 Erlang R15 来写的。如果你是一位来自未来的读者，那么文章里的情况可能会与你面对的现状有所不同。不过一般来说，未来总是会变得更好，无论是 Erlang ，还是系统的其它方面；

从操作系统层面来说，Erlang 通常会在计算机的每个核心上运行一个线程；每一个线程上运行的就是所谓的 scheduler 。这么做的原因，就是为了确保计算机的所有核心都能为 Erlang 系统工作。核心可以通过 `+sbt` 标识与调度器进行绑定；这样一来就可以保证，调度器无法在多个核心间“跳来跳去”。这个标识只能用于现代操作系统上，所以 OSX 是不能用的。这也意味着，Erlang 系统是了解处理器布局及亲缘（affinity）关系的，这些信息对缓存、迁移时间等都非常重要。通常情况下，`+sbt` 标识可以加速系统的运行，并且有些时候，加速很明显。

`+A` 标识定义了异步线程池中的线程数目。该池可被驱动程序用来执行某些阻塞操作，而与此同时，调度器仍可继续完成有用的工作。需要注意的是，该线程池可被文件驱动程序用于加速文件I/O，但不能加速网络 I/O 。

目前为止，我们讨论的都是 OS 内核层面轮廓性的东西，此时还需要介绍一下 Erlang（用户态）进程的概念。当调用 `spawn(fun worker/0)` 时，系统会构建一个新 Erlang 进程，具体来说，会在用户态为其分配一个进程控制块（PCB）。其大小一般为 600+ 字节，32 位和 64 位系统下有所不同。系统将可运行（待调度）进程放入调度器的 run queue 中，并在当它们获得时间片时即可运行。

在深入了解当个调度器之前，我想要先说明一下迁移的原理。进程偶尔会在调度器之间进行迁移，这是一个非常复杂的处理过程。迁移使用的启发式算法就是为了平衡所有调度器的负荷，保证所有核心能被有效地利用。与此同时，该算法也会考虑当前任务是否多到要启动新的调度器，如果没有，最好保持调度器处于关闭状态，这将意味着相应的核心可以进入节电模式并保持关闭。没错，Erlang 会尽量省电。调度器还可以在无工可开的情况下从别人那里「偷取」工作。详情可参看[这里][1]。

重要说明：在 R15 中，调度器的启停采取了“延迟“处理模式。意思是说，Erlang/OTP 认为调度器的启停很昂贵，只有它认为真正需要启停的时候才会去做这件事。比方说，现在某个调度器的情况是无工可开。但 Erlang 不会马上让它入睡，而是先让它继续跑一会（spin for a little while），看看有没有新工作进来。如果恰好有，那就可以很快开工了，这样可以做到非常小的延时。但另一方面，这也意味着我们不能用 top(1) 或其它 OS 内核工具来衡量系统的执行效率，而必须用 Erlang 系统的内部调用来确定。许多人之所以认为 R15 比 R14 差，就是因为这个原因。

每个调度器运行着两类作业：**进程作业**和**端口作业**。它们运行的时候可以指定优先级，类似于操作系统内核中的方式。我们可以将某个进程标识为高优先级、低优先级或其它优先级。进程作业执行的是进程。端口作业处理的是端口。需要知道的是，Erlang 中的“端口“是一种系统与外界通信的机制；文件、网络 socket、与其它程序交互的管道，都属于“端口“。程序员可以通过添加“端口驱动”的方式，支持新的端口类型，不过那需要写 C 代码。调度器还可以轮询网络 socket ，从中读取数据。

普通进程和端口进程都有默认为 2000 的 reduction 限制，称作 "reduction budget"；系统中的任何操作都会消耗 reduction 值，这包括：loop 中的函数调用、内置函数（BIF）调用、针对进程堆的垃圾回收、针对 ETS 表的保存和读取，以及消息发送（**接收者邮箱中的消息越多，向其发送消息的成本越高**）；可以说 reduction 计数无处不在；Erlang 的正则库已经被改写成用 c 实现，但同样需要进行 reduction 消耗计算，所以如果你长时间的进行正则运算，则会根据 reduction 消耗情况，多次被其它进程抢占执行；对于 Port 的情况也一样，在 Port 上进行 IO 操作会耗费 reduction 值，发送（分布式）消息也会；系统花费了大量精力以确保任何类型的步进都会产生相应的 reduction 消耗； 

> 进程堆是进程独立的，因此一个进程并不能对其它进程的 GC 时间产生多大影响；   
>
> 本段内容同时说明了为什么我们必须警惕需要长时间运行的 NIFs 。其运行默认不会被抢占，也不会触发 reduction 的减少。因此，会为系统引入延迟；

事实上，这就是我认为 Erlang 是真正实现了抢占式多任务调度，以及软实时的语言的原因；另外，Erlang 将时延看得比单纯的吞吐量更重要，这在各种编程语言的运行时中是不多见的。

更精确地来说，[抢占][2]意味着调度器可以强制让某个任务停止执行。基于协作的各种实现，包括 Python twisted, Node.js, LWT (Ocaml) 等等，都无法做到这一点。更有趣的是，即便 Go(golang.org)和 Haskell(GHC) 也不完全是抢占式的。Go 只在通信时切换上下文，因此一个 tight loop 就可能独占某个核心。GHC 则是在内存分配时进行切换（这种情况在 Haskell 程序中十分常见）。这些系统的问题在于，对核心的独占会影响整个系统的时延，大家可以想象一下在这些语言里执行数组操作的情形。

这就引出里[软实时][3]的概念，即使到达最后时间限定，系统也会采取降级策略保证服务可用。比如说，在 run queue 里存在 100 个进程。第一个进程需要执行的是数组操作，预计花费 50ms 时间。如果采用 Go 或者 Haskell/GHC 实现的话，则第 2-100 个进程就至少需要等待 50ms 后才能被处理。如果采用 Erlang 实现，第一个任务只会得到 2000 个 reduction 的执行时间，相当于 1ms 左右。当 1ms 过去后，系统就会把它放到队列尾部，换后面的第 2-100 个任务来运行。所有的任务都能公平地分到属于自己的那一份时间份额。

> 这里可以设想为单核情况；多核虽然依靠多个核心从某种程度上讲“消化”了问题，但问题其实仍然存在；

Erlang 是为保证**低时延**和**软实时**而精心打造的。2000 的 reduction 值非常小，因此会促成许多小的上下文切换。将耗时较长的 BIF 的执行进行拆分（基于 Trap 机制），以便其它中等计算单元能够进行抢占，这种实现方式虽然非常昂贵，但可以保证 Erlang 系统在面对更多工作任务时，以优雅的方式进行服务降级。在 Ericsson 这样需要低时延的公司里，Erlang 系统是无可替代的。你无法神奇的指望换一种面向吞吐量的语言，同时还能得到这么低的时延。除非你自己去搞定。坦白地说，如果低时延对于你来说是关键属性，那么不选择 Erlang 真的是很奇怪。


----------

(Smaller edits made to the document at Mon 14th Jan 2013)

原文地址：[这里](http://jlouisramblings.blogspot.dk/2013/01/how-erlang-does-scheduling.html)


[1]: http://kth.diva-portal.org/smash/record.jsf?searchId=2&pid=diva2:392243 "《多核心处理器中Erlang虚拟机可扩展性的特征》"
[2]: http://en.wikipedia.org/wiki/Preemption_(computing) 
[3]: http://en.wikipedia.org/wiki/Real-time_computing 


----------


# 关于 Erlang 调度的只言片语

Erlang 调度器主要完成对 Erlang 进程的调度，它是 Erlang 实现**软实时**和进程间公平使用 CPU 的关键。

## 参与调度的实体

在 Erlang 运行系统中，有 4 种任务需要被调度：进程，Port，Linked-in driver 和 Erlang VM 自身的系统级活动。

## Erlang 调度器特点

Erlang 调度器的特点：
- 进程调度运行在用户空间 ：Erlang 的进程调度是由 Erlang VM 来完成的；
- 调度是抢占式的：每一个进程在创建时，都会分配一个固定数目的 reduction（在 R15B 中，这个数量默认值是 2000），每一次操作（函数调用）reduction 都会减少，当这个数量减少到 0 时或者进程主动/被动挂起时，抢占就会发生（无视优先级）；
- 每个进程公平的使用 CPU ：每个进程分配相同数量的 reduction ，可以保证进程相对公平的（不是相等的）使用 CPU 资源；
- 调度器保证软实时性：Erlang 中的进程有优先级，调度器可以保证在下一次调度发生时，高优先级进程优先得到执行。

## 关于 reduction 的说明

> 关于 reduction 的说明
>>  在《Erlang 编程指南》一书中对 reduction 的说明如下：程序中的每一个命令，无论它是一个函数调用，还是一个算术操作，或者内置函数，都会分配一定数量的 reduction 。虚拟机使用这个值来衡量一个进程的活动水平。


### 如果一个函数调用的执行时间很长怎么办？

换句话说，其所属进程是否会长时间占用 CPU 资源？Erlang 解决这个问题的方案是：**Trap 机制**；Trap 机制的其中一个功能就是把费时的操作分阶段做，比如 lists:reverser 和 lists:member 可能会根据输入的规模大小有很大的耗时差别，此时就会使用到 Trap 机制；先执行一段时间，再 Trap ，然后再次被调度到时，再继续执行。


## SMP 支持问题

> ⚠️ 为了方便和其它地方的概念对接，进行如下名词说明：
>> 调度器即 scheduler ；    
>> 运行队列即 run queue ；    

Erlang 对 SMP 的支持分为以下几个阶段：
1. **单调度器、单运行队列**：调度器运行在虚拟机主进程中的一个线程中，从单个任务队列中获取运行进程，因为只有一个线程，所以对运行队列的访问不需要锁；    
2. **多调度器、单运行队列**：调度器的个数可以自定义（参见 erl 命令的 +S 参数，默认数量同 CPU 核的数量）；每个调度器运行在一个线程中，但是只有一个运行队列，所有调度器都从同一个运行队列获取运行进程，所以会涉及到共享资源的访问，需要用到锁；    
3. **多调度器、多运行队列**：每个调度器都绑定有一个运行队列，每个调度器都从各自的运行队列中获取待运行进程。相比单运行队列，多运行队列会减少锁冲突，提高性能，但是，因为涉及到多运行队列，就必需要考虑负载问题：如果一个调度器很忙，另一个很闲，那怎么办？Erlang 虚拟机存在一个任务迁移的逻辑，来保证各个调度器达到平衡；    

关于 SMP 还可以参考另外一篇总结：《[Inside the Erlang VM](https://github.com/moooofly/MarkSomethingDown/blob/master/Inside%20the%20Erlang%20VM.md)》


## 关于进程优先级

Erlang 进程存在四种优先级：max, high, normal, low ；
在 Erlang 运行时中，max 和 high 优先级的运行任务，normal和low在同一个队列中。



上述内容整理自：[这里](http://jzhihui.iteye.com/blog/1482175)


在本文里，我将说明为什么 Erlang 的运行时会与其它语言的运行时有所不同，还将说明为什么它经常会采取放弃吞吐量的方式以换取更小的延时。

摘要：Erlang 与其它大多数语言的运行时差异源于双方有着不同的目标价值。我们常常发现 Erlang 在进程不多时表现不佳，反而在进程很多时表现优异，原因也在于此。

长久以来，关于 Erlang 的调度方式问题总是被人们问起。尽管本文是真实情况的缩减版本，但仍可作为针对这个问题的解答。需要留意的是，本文是基于 Erlang R15 来写的。如果你是一位来自未来的读者，那么文章里的情况可能会与你面对的现状有所不同。不过一般来说，未来总是会变得更好，无论是 Erlang ，还是系统的其它方面；

从操作系统层面来说，Erlang 通常会在计算机的每个核心上运行一个线程；每一个线程上运行的就是所谓的 scheduler 。这么做的原因，就是为了确保计算机的所有核心都能为 Erlang 系统工作。核心可以通过 `+sbt` 标识与调度器进行绑定；这样一来就可以保证，调度器无法在多个核心间“跳来跳去”。这个标识只能用于现代操作系统上，所以 OSX 是不能用的。这也意味着，Erlang 系统是了解处理器布局及亲缘（affinity）关系的，这些信息对缓存、迁移时间等都非常重要。通常情况下，`+sbt` 标识可以加速系统的运行，并且有些时候，加速很明显。

`+A` 标识定义了异步线程池中的线程数目。该池可被驱动程序用来执行某些阻塞操作，而与此同时，调度器仍可继续完成有用的工作。需要注意的是，该线程池可被文件驱动程序用于加速文件I/O，但不能加速网络 I/O 。

目前为止，我们讨论的都是 OS 内核层面轮廓性的东西，此时还需要介绍一下 Erlang（用户态）进程的概念。当调用 `spawn(fun worker/0)` 时，系统会构建一个新 Erlang 进程，具体来说，会在用户态为其分配一个进程控制块（PCB）。其大小一般为 600+ 字节，32 位和 64 位系统下有所不同。系统将可运行（待调度）进程放入调度器的 run queue 中，并在当它们获得时间片时即可运行。

在深入了解当个调度器之前，我想要先说明一下迁移的原理。进程偶尔会在调度器之间进行迁移，这是一个非常复杂的处理过程。该启发式算法的目的就是为了平衡所有调度器的负荷，保证所有核心能被有效地利用。与此同时，该算法也会考虑工作是否多到要启动新的调度器，如果没有，最好保持调度器处于关闭状态，这将意味着相应的核心可以进入节电模式并保持关闭。没错，Erlang 会尽量省电。调度器还可以在无工可开的情况下从别人那里「偷取」工作。详情可参看[这里][1]。

重要说明：在 R15 中，调度器的启停采取了“延迟“处理模式。意思是说，Erlang/OTP 认为调度器的启停很昂贵，只有它认为真正需要启停的时候才会去做这件事。比方说，现在某个调度器的情况是无工可开。但 Erlang 不会马上让它入睡，而是先让它继续跑一会（spin for a little while），看看有没有新工作进来。如果恰好有，那就可以很快开工了，这样可以做到非常小的延时。但另一方面，这也意味着我们不能用 top(1) 或其它 OS 内核工具来衡量系统的执行效率，而必须用 Erlang 系统的内部调用来确定。许多人之所以认为 R15 比 R14 差，就是因为这个原因。

每个调度器运行着两类作业：进程作业和端口作业。它们运行的时候可以指定优先级，类似于操作系统内核中的方式。我们可以将某个进程标识为高优先级、低优先级或其它优先级。进程作业执行的是进程。端口作业处理的是端口。需要知道的是，Erlang 中的“端口“是一种系统与外界通信的机制；文件、网络 socket、与其它程序交互的管道，都属于“端口“。程序员可以通过添加“端口驱动”的方式，支持新的端口类型，不过那需要写 C 代码。调度器还可以轮询网络 socket ，从中读取数据。

普通进程和端口进程都有 2000 个运行次数（reduction）限制，称作 "reduction budget"；系统中的任何操作都会消耗 reduction 值，这包括：loop 中的函数调用、内置函数（BIF）调用、针对进程堆的垃圾回收、针对 ETS 表的保存和读取，以及消息发送（接收者邮箱中的消息越多，发送的成本越高）；可以说 reduction 计数无处不在；Erlang 的正则库已经被改写成用 c 实现，但同样需要进行 reduction 消耗计算，所以如果你长时间的进行正则运算，则可能会根据 reduction 消耗情况，多次被其它进程抢占执行；对于 Port 的情况也一样，在 Port 上进行 IO 操作会耗费 reduction 值，发送（分布式）消息也会；系统花费了大量时间以确保任何类型的步进兜会产生相应的 reduction 消耗； 

> 进程堆是进程独立的，因此一个进程并不能对其它进程的 GC 时间产生多大影响；   
>
> 本段内容同时说明了为什么我们必须警惕需要长时间运行的 NIFs 。其运行默认不会被抢占，也不会触发 reduction 的减少。因此，会为系统引入延迟；

事实上，这就是我认为 Erlang 是真正实现了抢占式多任务调度，以及软实时的语言的原因；另外，Erlang 将时延看得比单纯的吞吐量更重要，这在各种编程语言的运行时中是不多见的。

更精确地来说，[抢占][2]意味着调度器可以强制让某个任务停止执行。基于协作的各种实现，包括Python twisted, Node.js, LWT (Ocaml) 等等，都无法做到这一点。更有趣的是，即便 Go(golang.org)和 Haskell(GHC) 也不完全是抢占式的。Go 只在通信时切换上下文，因此一个 tight loop 就可能独占某个核心。GHC 则是在内存分配时进行切换（这种情况在 Haskell 程序中十分常见）。这些系统的问题在于，对核心的独占会影响整个系统的时延，大家可以想象一下在这些语言里执行数组操作的情形。

这就引出里[软实时][3]的概念，即使到达最后时间限定，系统也会采取降级策略保证服务可用。比如说，在 run queue 里存在 100 个进程。第一个进程需要执行的是数组操作，预计花费 50ms 时间。如果采用 Go 或者 Haskell/GHC 实现的话，则第 2-100 个进程就至少需要等待 50ms 后才能被处理。如果采用 Erlang 实现，第一个任务只会得到 2000 个 reduction 的执行时间，相当于 1ms 左右。当 1ms 过去后，系统就会把它放到队列尾部，换后面的第 2-100 个任务来运行。所有的任务都能公平地分到属于自己的那一份时间份额。

> 这里可以设想为单核情况；多核虽然依靠多个核心从某种程度上讲“消化”了问题，但问题其实仍然存在；

Erlang 是为保证**低时延**和**软实时**而精心打造的。2000 的 reduction 值非常小，因此会促成许多小的上下文切换。将需要花费较长时间执行的 BIF 从时间片角度进行拆分，以便其可以被中等计算单元所抢占，是非常昂贵。但这可以保证 Erlang 系统在面对更多工作任务时，以优雅的方式进行服务降级。在 Ericsson 这样需要低时延的公司里，Erlang 系统是无可替代的。你无法神奇的指望换一种面向吞吐量的语言，同时还能得到这么低的时延。除非你自己去搞定。坦白地说，如果低时延对于你来说是关键属性，那么不选择 Erlang 真的是很奇怪。


----------

(Smaller edits made to the document at Mon 14th Jan 2013)

原文地址：[这里](http://jlouisramblings.blogspot.dk/2013/01/how-erlang-does-scheduling.html)


[1]: http://kth.diva-portal.org/smash/record.jsf?searchId=2&pid=diva2:392243 "《多核心处理器中Erlang虚拟机可扩展性的特征》"
[2]: http://en.wikipedia.org/wiki/Preemption_(computing) 
[3]: http://en.wikipedia.org/wiki/Real-time_computing 



# 使用姿势


- 由需要的功能决定使用何种数据结构进行存储；
- 在构建键的命名空间时使用冒号作为分隔符；
- **过期时间设置粒度**：对于**列表**、**集合**、**散列**和**有序集合**这几种容器类型来说，键过期命令只能为整个键设置过期时间，而没办法为键里面的单个元素设置过期时间（替代方案：使用存储时间戳的有序集合来实现针对单个元素的过期操作）；
- **SSD** 和 `appendfsync always` 组合可能导致问题发生：请谨慎使用这种组合，因为该配置选项会让 Redis 每次只写入一个命令，而不像其他 `appendfsync` 选项那样一次写入多个命令，这种不断地写入少量数据的做法有可能会引发严重的**“写入放大“**问题；在某些情况下，甚至会将固态硬盘的寿命从原来的几年降低为几个月；
- 一般来说，当程序使用一个来自 Redis 的值去构建另一个将要被添加到 Redis 里面的值时，就需要使用锁或者由 `WATCH`、`MULTI` 和 `EXEC` 组成的事务来消除竞争条件；


# 经验值

- 查询本地 Redis 的延迟值通常低于 **1ms** ，而查询位于同一个数据中心的 Redis 的延迟值通常低于 **5ms** ；
- Redis 处理命令的速度受硬盘性能的限制：**转盘式硬盘（spinning disk）**在 `appendfsync always` 同步频率下每秒只能处理大约 200 个写命令；而**固态硬盘（SSD）**每秒大概也只能处理几万个写命令；
- Redis 以 `appendfsync everysec` 配置写 AOF 文件时的性能和不使用任何持久化特性时的性能相差无几；
- 当硬盘忙于执行写入操作的时候，Redis 会优雅的放慢自己的速度以适应硬盘的最大写入速度；



# 可能导致阻塞的点

- 对**集合**和**有序集合**进行操作时，若涉及的元素可能有上万个或者上百万个时，执行操作所花费的时间可能需要以秒来进行计算，导致**服务器阻塞**；
- 如果**散列**中包含的值非常大，那么用户可以先使用 `HKEYS` 命令取出**散列**中包含的所有键，然后再使用 `HGET` 一个接一个地取出键的值，从而避免因为一次获取多个大体积的值而导致**服务器阻塞**；或者只获取必要的值，以便减少需要传输的数据量；
- 无论是 RDB 持久化（`BGSAVE`），还是 AOF 重写（`BGREWRITEAOF`）都会在 fork 子进程时，随内存占用量大小的增加，导致主进程卡顿时间变长（阻塞）；
- 在不做适当控制的情况下，AOF 文件的体积可能会比快照文件的体积大好多倍，在进行 AOF 重写操作时，将面临如下问题：删除一个体积达到数十 GB 大的旧 AOF 文件可能会导致操作系统挂起（hang）数秒；
- 如果用户的硬盘处理写入操作的速度不够快的话，那么当缓冲区被等待写入硬盘的数据填满时，Redis 的写入操作将被阻塞，并导致 Redis 处理命令的请求的速度变慢；因此，一般来说不推荐使用 `appendfsync no` 选项；
- 当多个从服务器同时连接主服务器的时候，同步多个从服务器所占用的带宽可能会使得其他命令请求难以传递给主服务器，与主服务器位于同一网络中的其他硬件（设备）的网络可能也会因此而降低；随着主服务器的负载不断上升，可能会无法快速的更新所有从服务器，或者因为**重新连接**和**重新同步**从服务器而导致系统超载；（⚠️ 一主多从场景和一台物理机上跑多个主，每个主都配有一个从的场景应该是类似的；）
- 如果主服务器**没有足够的内存**来创建子进程和用于记录写命令的缓冲区，那么 Redis 处理命令请求的效率就会受到影响（卡顿或阻塞）；




# Redis 已知问题

## pub/sub 问题

### 从 Redis 系统的稳定性角度来说

- 对于**旧版本** Redis 来说，若客户端订阅了某个或某些 channel ，但读取消息的速度不够快，那么不断积压的消息会使得 Redis 的**输出缓冲区**的体积越来越大，进而导致 Redis 的速度变慢，甚至直接崩溃；也可能被操作系统强制杀死，甚至导致操作系统本身不可用；
- 对于**新版本** Redis 来说，则不会出现上述问题，因为其会自动断开不符合 `client-output-buffer-limit pubsub` 配置选项要求的订阅客户端；

### 从数据传输的可靠性角度来说

如果客户端在执行订阅操作的过程中发生断线，那么客户端会丢失在断线期间发送的所有消息；

## 事务问题

Redis 中实现的事务可以让一个客户端在**不被其他客户端打断**的情况下执行多个命令；即被 `MULTI` 命令和 `EXEC` 命令包围的所有命令会一个接一个的执行，直到所有命令执行完毕为止；只有当一个事务执行完毕后，Redis 才会处理其他客户端的命令；

### 事务的优点

- 在 Redis 中使用事务的一个主要作用是**移除竞争条件**；
- 另外一个好处是：底层一般会使用 pipeline 来提高事务执行时的性能；

### 事务的缺点

- 可能会导致其他命令被延迟执行；
- Redis 中事务的不完善问题；

> Redis 中的**流水线（pipeline）**
>> - 在 Redis 中使用流水线的一个目的是提高性能；
>> - **流水线**是指“一次性发送多个命令，然后等待所有回复出现“；


## 快照持久化问题（RDB）

- 在新的快照文件创建完毕前，如果 Redis、系统或者硬件这三者之中的任意一个崩溃了，那么 Redis 将丢失最近一次创建快照之后写入的所有数据；
- 适用于即使丢失一部分数据也不会造成问题的应用；

### 快照生成条件

- 基于 `BGSAVE` 命令创建快照，fork 子进程处理，不阻塞主进程；
- 基于 `SAVE` 命令创建快照，在主进程中处理，因此在快照创建完毕前，不再响应任何其他命令，阻塞主进程；
- 基于 `save <seconds> <changes>` 配置项创建快照，等同于 `BGSAVE` 方式；
- 通过 `SHUTDOWN` 关闭 Redis 服务器的时候，或者接到标准的 `TERM` 信号时，Redis 会执行 `SAVE` 命令；
- 当 slave 连接到 master 后，通过 `SYNC` 命令开始复制操作时，如果 master 目前没有在执行 `BGSAVE` 操作，或者 master 并非刚刚执行完 `BGSAVE` 操作，那么 master 就会执行 `BGSAVE` 命令；

> ⚠️ 这里讨论的“阻塞“问题是比较粗力度的，因此认为  `BGSAVE` 命令不会阻塞主进程；但从细粒度来说，`BGSAVE` 命令同样会导致主进程阻塞，详见后文；

### 快照和数据量（内存占用）的关系

- 当 Redis 存储的数据量只有**几个 GB** 的时候，使用快照（无论 `SAVE` 或 `BGSAVE`）保存数据的速度是非常快的；
- 当 Redis 的内存占用量达到**数十个 GB** ，并且剩余的空闲内存并不多时，或者 Redis 运行在虚拟机上时，那么 `BGSAVE` 可能会导致系统长时间停顿，也可能引发系统大量的使用虚拟内存，从而导致 Redis 的性能降低至无法使用的程度；

### 卡顿时间估算（fork 子进程导致）

执行 `BGSAVE` 而导致的停顿时间与 Redis 所在系统有关：
- 对于真实的硬件、**VMWare** 虚拟机或者 **KVM** 虚拟机来说，Redis 进程每占用一个 GB 的内存，创建子进程所需的时间就要增加 **10 ~ 20 ms** ；
- 对于 **Xen** 虚拟机来说，根据配置的不同，Redis 进程每占用一个 GB 的内存，创建子进程所需的时间就要增加 **200 ~ 300 ms** ；


## AOF 持久化问题

- AOF 文件的体积大小会随着不断执行的写命令而不断增大，进而可能导致硬盘可用空间的耗尽；
- 过大的 AOF 文件会导致还原操作的执行时间非常长；

解决 AOF 文件体积过大问题：基于 `BGREWRITEAOF` 命令实现 AOF 文件的重写（fork 子进程，不阻塞主进程）；

> ⚠️ AOF 持久化同样会遇到快照持久化方案中遇到**性能问题**和**内存占用**问题；

除此之外，在不做适当控制的情况下，AOF 文件的体积可能会比快照文件的体积大好多倍，在进行 AOF 重写操作时，将面临如下问题：删除一个体积达到数十 GB 大的旧 AOF 文件可能会导致操作系统**挂起（hang）**数秒；


## master-slave 复制问题

- 如果主从服务器之间的**网络带宽不足**，或者主服务器**没有足够的内存**来创建子进程和记录写命令的缓冲区，那么 Redis 处理命令请求的效率就会受到影响；在实际中，最好让主服务器只使用 **50％ ~ 60％** 的内存，留下 **30％ ~ 45％** 的内存用于执行 `BGSAVE` 命令和创建记录写命令的缓冲区；
- 从服务器在进行同步时，会清空自己的所有数据；
- Redis 不支持主主复制；


### 一主多从可能会产生的问题

当多个从服务器同时连接主服务器的时候，同步多个从服务器所占用的带宽可能会使得其他命令请求难以传递给主服务器，与主服务器位于同一网络中的其他硬件（设备）的网络可能也会因此而降低；随着主服务器的负载不断上升，可能会无法快速的更新所有从服务器，或者因为**重新连接**和**重新同步**从服务器而导致系统超载；

> ⚠️ 一主多从场景和一台物理机上跑多个主，每个主都配有一个从的场景应该是类似的；




# repl-disable-tcp-nodelay


在slave和master同步后（发送psync/sync），后续的同步是否设置成TCP_NODELAY
假如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟（40ms），造成master与slave数据不一致
假如设置成no，则redis master会立即发送同步数据，没有延迟
前者关注性能，后者关注一致性

40ms是Nagle和TCP确认延迟机制共同作用的结果


# gossip 


无中心架构的网络通信对带宽的影响；

# cluster 中的 master-slave 问题

一个Redis  Node包含一定量的桶，当这些桶对应的Master和Slave都挂掉时，这部分桶对应的数据不可用；进而根据配置可能导致整个集群的不可用；


# cluster 中 master-slave 异步复制数据丢失问题

一个完整的写操作步骤：
1.client写数据到master
2.master告诉client "ok"
3.master传播更新到slave
存在数据丢失的风险：
1. 上述写步骤1）和2）成功后，master crash，而此时数据还没有传播到slave
2. 由于分区导致同时存在两个master，client向旧的master写入了数据。
当然，由于Redis Cluster存在超时及故障恢复机制，第2个风险基本上不可能发生











